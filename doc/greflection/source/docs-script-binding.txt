<{filename name=docs-cpgf-script-binding }>

<{title}>cpgf script binding engine -- bind Lua and Google V8 Javascript to C++<{/title}>

<{include name="cpgf-header.inc" }>

<h1>script binding engine -- bind Lua and Google V8 Javascript to C++</h1>

<{autotoc}>

<{sgroup}>Binding Lua  and Google V8 Javascript engine to C++

<{sh}> Overview
<{sc}>

<{autobr}>
The binding engine uses reflection meta data as the source.
<{/autobr}>


<{sh}> What can the binding engine do
<{sc}>

<{autoul}>
Bind C++ class to Lua and Google V8 Javascript. Then Lua and Javascript can create instance, invoke class member function, get/set class field or property, and more.
Bind C++ enum type to Lua and V8 Javascript. Then Lua and Javascript can access the enum value by name.
Bind C++ functions (global or member) to Lua and V8.
Bind C++ values to Lua and V8 variable.
Bind C++ operators to Lua (Lua only). The overloaded operators in C++ are bound to Lua together with the class.
Invoke Lua and V8 Javascript functions from C++.
Get and set Lua and V8 Javascript value from C++.
<{/autoul}>


<{sh}> Get start
<{sc}>

<{autobr}>
To binding Lua, include the header,
cpgf/scriptbind/gluabind.h
For V8, include the head,
cpgf/scriptbind/gv8bind.h

First, we need a GScriptObject or IScriptObject (the interface version) object.

Lua version:
GScriptObject * createLuaScriptObject(IMetaService * service, lua_State * L, const GScriptConfig & config);
IScriptObject * createLuaScriptInterface(IMetaService * service, lua_State * L, const GScriptConfig & config);

The first parameter is a IMetaService. You can call createDefaultMetaService() or createMetaService() to create the service.
The second parameter is the Lua state.
The third one is a config. Just call GScriptConfig() to construct default one.

V8 version:
GScriptObject * createV8ScriptObject(IMetaService * service, v8::Local<v8::Object> object, const GScriptConfig & config);
IScriptObject * createV8ScriptInterface(IMetaService * service, v8::Local<v8::Object> object, const GScriptConfig & config);

The first parameter is a IMetaService. You can call createDefaultMetaService() or createMetaService() to create the service.
The second parameter is the V8 global object.
The third one is a config. Just call GScriptConfig() to construct default one.


This script object acts as a global scope. All meta data bound to this script object will be bound into Lua/V8 global space.
New named scope can be create by calling GScriptObject::createScriptObject(TheName).
Then all meta data bound to TheName can be accessed via TheName.
Such as TheName.MyClass, etc.

After getting the GScriptObject object, we get everything ready to bind the meta data to Lua and V8.

<{/autobr}>



<{sh}> Script object API
<{sc}>

<{autobr}>
<{piece}> virtual void bindClass(const char * name, IMetaClass * metaClass) = 0; <{/piece}>
Bind the meta class under the name.
After binding, all meta data are exposed to the script.
Thus the script can invoke the class member function, access field/property, invoke operator (Lua only), etc.

Some examples,

scriptObject->bindClass(metaClass->getName(), metaClass);
Bind metaClass under its meta name.

scriptObject->bindClass("MyClass", metaClass);
Bind metaClass under "MyClass".

In Lua, the script can always invoke the class name to construct new instance.
a = MyClass()
a is constructed with the default constructor.
b = MyClass(5)
b is constructed with the constructor that accepts an integer.

In Google V8 Javascript, the keyword "new" must be used to invoke the constructor.
a = new MyClass()
a is constructed with the default constructor.
b = new MyClass(5)
b is constructed with the constructor that accepts an integer.

<{piece}> virtual void bindEnum(const char * name, IMetaEnum * metaEnum) = 0; <{/piece}>
Bind the meta enumerator to script.
Assume we have the enumerator,
enum MyEnum { x, y, z };
After binding MyEnum, in the script, we can access the value by,
a = MyEnum.x
b = MyEnum.y

<{piece}> virtual void bindFundamental(const char * name, const GVariant & value) = 0; <{/piece}>
Bind the fundamental value to script.
A fundamental value is the value with primary type, such as integer, float, bool, double, etc.

<{piece}> virtual void bindAccessible(const char * name, void * instance, IMetaAccessible * accessible) = 0; <{/piece}>
Bind a field or property to script. Here accessible means a field or property.
Lua binding performance warning: binding an accessible to a script object may slow down the accessing to that script object.
So if performance is important for you, don't bind accessible to global script object.
Google V8 doesn't have this impact.

<{piece}> virtual void bindString(const char * stringName, const char * s) = 0; <{/piece}>
Bind a string to script.
After binding, "s" is safe to be freed in C++. The script will hold a copy of the string.

<{piece}> virtual void bindObject(const char * objectName, void * instance, IMetaClass * type, bool transferOwnership) = 0; <{/piece}>
Bind an object instance to script.
"instance" is the object pointer.
"type" is the meta class for the object.
If "transferOwnership" is true, the object will be freed by the script. If it's false, the C++ code will be responsible to free the object.

<{piece}> irtual void bindRaw(const char * name, const GVariant & value) = 0; <{/piece}> 
Bind raw object to script.
A raw object, is either a pointer or object.
This is useful to bind object which has no meta data, aka, not reflected.
The parameter "value" must hold a pointer, or an object. It can't be fundamental or string.
The script can't access any members in the raw object.
The script can only store the raw object and pass the object back to C++.

<{piece}> virtual void bindMethod(const char * name, void * instance, IMetaMethod * method) = 0; <{/piece}>
Bind a C++ function to script.
"instance" is the object instance for the function. It's NULL for global function.
"method" is the meta method.
method can be a class member function, and "instance" should point to the object. Then the method will behave as a global function in current script object.
For example, if we have an object "obj" of MyClass, and it has a method "add",
Pseudo code: bindMethod("AnotherAdd", obj, meta method of MyClass::add);
Then in script, to call the method, just write "AnotherAdd(blah, blah)", no object is required.

Note: only use this function to bind method in global scope. You don't need to bind member function for class. bindClass will do it for you.

<{piece}> virtual void bindMethodList(const char * name, IMetaList * methodList) = 0; <{/piece}>
Bind a group of C++ functions to script under the "name".
Then all methods are treated as overloaded functions in the script.
Pseudo code:
methodList->add(meta method of MyClass::addLess, &myObject); // int addLess(int)
methodList->add(meta method of global addMore, NULL); // int addMore(int a, int b)
bindMethodList("add", methodList);
Then in script, "add(5)" will invoke MyClass::addLess, "add(8, 9)" will invoke addMore.

<{piece}> virtual IMetaClass * getClass(const char * className) = 0; <{/piece}>
Return the meta class that's bound to script using the API bindClass;

<{piece}> virtual IMetaEnum * getEnum(const char * enumName) = 0; <{/piece}>
Return the meta enum that's bound to script using the API bindEnum;

<{piece}> virtual GVariant getFundamental(const char * name) = 0; <{/piece}>
Return the fundamental value that's bound to script using the API bindFundamental;

<{piece}> virtual std::string getString(const char * stringName) = 0; <{/piece}>
Return the string that's bound to script using the API bindString;

<{piece}> virtual void * getObject(const char * objectName) = 0; <{/piece}>
Return the object that's bound to script using the API bindObject;
To get the meta class of the object, call getType.

Note: Don't free the returned object.

<{piece}>virtual GVariant getRaw(const char * name) = 0; <{/piece}>
Return a raw object.

<{piece}> virtual IMetaMethod * getMethod(const char * methodName) = 0; <{/piece}>
Return the meta method that's bound to script using the API bindMethod.
This function will return NULL for the method that's bound by bindClass,

<{piece}> virtual IMetaList * getMethodList(const char * methodName) = 0; <{/piece}>
Return the meta method list that's bound to script using the API bindMethodList.
This function will return NULL for the method list that's bound by bindClass,

<{piece}> virtual GScriptDataType getType(const char * name, IMetaTypedItem ** outMetaTypeItem) = 0; <{/piece}>
Get the type of a name in the script engine. The name can be any legal name that exists in the script engine.
If "outMetaTypeItem" is not NULL and if the name has a meta type, the meta type will be stored into outMetaTypeItem.
In this case, you must call releaseReference on outMetaTypeItem to release it after finishing using it.

Here is the list of the data type,
	sdtUnknown -- can't determine the type
	sdtNull -- NULL. It's nil in Lua and null or undefined in Javascript.
	sdtFundamental -- fundamental type. Can be boolean, integer, float, etc.
	sdtString -- string. Can be obtained as C string.
	sdtClass -- C++ class that bound to the script engine.
	sdtObject -- C++ object.
	sdtMethod -- C++ function.
	sdtMethodList -- a group of C++ functions.
	sdtEnum -- C++ enumerator.
	sdtScriptObject -- A script object. Meta data can be added to it. C++ object is NOT script object.
	sdtScriptMethod -- Function in the script.

<{piece}> virtual GScriptObject * createScriptObject(const char * name) = 0; <{/piece}>
Create a new script object int current script object.
The new script object can be used to bind meta data.
If "name" is a C++ object, the function will fail and return NULL.

Note: you should free the returned object.

<{piece}> virtual GScriptObject * gainScriptObject(const char * name) = 0; <{/piece}>
Get existing script object int current script object.
The script object can be used to bind meta data.
If "name" is a C++ object, the function will fail and return NULL.

Note: you should free the returned object.

<{piece}> virtual GVariant invoke(const char * name, const GVariant * params, size_t paramCount) = 0; <{/piece}>
Invoke a function named "name" in the script.
This can be any function, such as a function written in script, or a C++ function bound to the script.
The parameters are passed as a pointer to a GVariant.

<{piece}> virtual GVariant invokeIndirectly(const char * name, GVariant const * const * params, size_t paramCount) = 0; <{/piece}>
Same as "invoke", but the parameters are passed as a pointer to a GVariant pointer.

<{piece}> virtual void assignValue(const char * fromName, const char * toName) = 0; <{/piece}>
Assign a script value named "fromName" to another script value named "toName".

<{piece}> virtual bool valueIsNull(const char * name) = 0; <{/piece}>
Return true if the script value is null.
Note: Any empty value, undefined value, and null value, are treated as null.

<{piece}> virtual void nullifyValue(const char * name) = 0; <{/piece}>
Set the script value to null.
This is helpful to release any bound value in the script.

<{/autobr}>


<{sh}> Utility API
<{sc}>

<{autobr}>
To easy the use, there are some utility APIs in gscriptbindutil.h


<{piece}>GMetaVariant invokeScriptFunction(GScriptObject * scriptObject, const char * name, GMetaVariant P1, GMetaVariant P2, ..., GMetaVariant PN); <{/piece}>
<{piece}>GMetaVariant invokeScriptFunction(IScriptObject * scriptObject, const char * name, GMetaVariant P1, GMetaVariant P2, ..., GMetaVariant PN); <{/piece}>

Invoke a script function.
Example,
<{piece}>GMetaVariant result = invokeScriptFunction(binding, "funcAdd", 8, 2); <{/piece}>

<{piece}>IScriptObject * scriptObjectToInterface(GScriptObject * scriptObject); <{/piece}>
Wrap GScriptObject object to IScriptObject.
Note: the returned interface will not own the scriptObject. The caller should delete scriptObject.

<{piece}>IScriptObject * scriptObjectToInterface(GScriptObject * scriptObject, bool freeObject); <{/piece}>
If freeObject is true, the returned interface will free the script object.

<{piece}>void injectMetaClassToScript(IScriptObject * scriptObject, IMetaClass * metaClass, void * instance); <{/piece}>
Inject a class to the script. It will bind all methods, enumerators, nested class, in metaClass, to scriptObject in global scope.
"instance" is the object if metaClass is not global.
The function is usually only useful to bind the whole global meta class.
So if metaClass is a top level global class, calling
<{piece}>injectMetaClassToScript(myScriptObject, globalClass, NULL); <{/piece}>
will bind everything in the meta system to the script.

<{/autobr}>


<{sh}> Passing script function and object to C++
<{sc}>

<{autobr}>
The script function and object here are the function and object defined in the script, not exposed by C++.
When the script is calling a C++ function, or setting a property, a script function will be wrapped in a IScriptFunction interface, and a script object will be wrapped in a IScriptObject interface.
Then the C++ code can use the interfaces to access the script function and object.

Notes:
1, If the script interface is passed as method parameter, don't release it. The caller will release it.
2, Don't pass script interface to field. You should use property with getter and setter to set the data.
In the setter, addReference must be called on the interface to retain it. Otherwise, the interface will be released by the script.

<{/autobr}>




<{/sgroup}>


<{/autotoc}>

<{include name="cpgf-footer.inc" }>
