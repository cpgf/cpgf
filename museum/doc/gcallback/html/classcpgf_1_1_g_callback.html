<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cppcallback: cpgf::GCallback&lt; Signature &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacecpgf.html">cpgf</a>      </li>
      <li><a class="el" href="classcpgf_1_1_g_callback.html">GCallback</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>cpgf::GCallback&lt; Signature &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="cpgf::GCallback" -->
<p><code>#include &lt;<a class="el" href="gcallback_8h_source.html">gcallback.h</a>&gt;</code></p>

<p><a href="classcpgf_1_1_g_callback-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback.html#a854d801eef209bf5172d1d0b1e61fda5">GCallback</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename OT , typename FT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback.html#aaf9d350059615fc81580a7db8ab4c951">GCallback</a> (OT *obj, const FT &amp;func)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename FT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback.html#a0c13710db5e9189390f612d2ded90797">GCallback</a> (FT &amp;func)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename FT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback.html#a16590124d158082c9a21061d578ee94e">GCallback</a> (const FT &amp;func)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename FT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback.html#ae85101703c93a919986bbf4cc5ecac7c">GCallback</a> (const volatile FT &amp;func)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback.html#a42731a458a6ef642b2c9f7a0d57bef00">GCallback</a> (const ThisType &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcpgf_1_1_g_callback.html">GCallback</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback.html#add48364194dc7d858c58d75b571d9c56">operator=</a> (const ThisType &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback.html#a6a73bd959204ba89c1e7daee034d8215">operator==</a> (const ThisType &amp;other) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback.html#a5f6e947139194c9442b3d11db6bde901">operator!=</a> (const ThisType &amp;other) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback.html#a28bf091f14899532b86828a6eed25aad">invoke</a> (PT1 p1, PT2 p2...PTn pn) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">RT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback.html#a26af038aa5e1d796e39547e73929fa1a">operator()</a> (PT1 p1, PT2 p2...PTn pn) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback.html#abf7261ff1c6a5cc18cdae7bad96b769d">getObject</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback.html#ab5e87163ad1fde5de29c4aa9ac48fca1">setObject</a> (void *obj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback.html#a63ba97a83eda4474bcfcf5ab7e31edfc">empty</a> () const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename Signature&gt;<br/>
 class cpgf::GCallback&lt; Signature &gt;</h3>

<p>The callback object is useful to represent any functions. <br/>
 It can be used with any functions, include global function, member function, virtual member function, static member function, functor object (an object with () operator), etc. <br/>
 The callback is the same concept of slot in other implementation, such as Qt, boost::Signals, and libsigc++. <br/>
 The template parameter 'Signature' is the function type, or a pointer type that points to a function (aka, function pointer). <br/>
 <a class="el" href="classcpgf_1_1_g_callback.html">GCallback</a>&lt;void ()&gt; --&gt; void foo(); // signature is a function type. <br/>
 <a class="el" href="classcpgf_1_1_g_callback.html">GCallback</a>&lt;void (*)()&gt; --&gt; void foo(); // signature is a function pointer. <br/>
 <a class="el" href="classcpgf_1_1_g_callback.html">GCallback</a>&lt;int (double, char)&gt; --&gt; int foo(double, char); <br/>
 <a class="el" href="classcpgf_1_1_g_callback.html">GCallback</a>&lt;void __stdcall (int)&gt; --&gt; void foo(int n); // __stdcall is ignored, Note the type <a class="el" href="classcpgf_1_1_g_callback.html">GCallback</a>&lt;void __stdcall (int)&gt; is not equal to <a class="el" href="classcpgf_1_1_g_callback.html">GCallback</a>&lt;void (int)&gt;, though they behave exactly the same. <br/>
</p>
<p>The Signature can be in any format as long as it constructs a valid function type or function pointer type. <br/>
 The Signature can include calling convention and class qualifier. <br/>
 Any calling convention and class qualifier will be ignored. <br/>
 So for two Signatures, if they have same argument count and types and result type, even they have different calling convention and class type (so they ar different function signature), the callback will behave exactly the same. <br/>
 But always keeps in mind, different signatures, will produce different callback types, even if all callback types behave the same. <br/>
 So it's highly recommended that we should better stick to consistent signature format. For example, always using function type without any calling convention or class type should be the best. <br/>
</p>
<p>Please alwasy prefer function type to function pointer. If you don't want, please keep consistent. <br/>
 GCallback&lt;Function type&gt; is not equal to GCallback&lt;Function pointer&gt;. Though they behave exactly the same, they are different C++ types. <br/>
 Assigning a callback which is a type GCallback&lt;Function type&gt; to GCallback&lt;Function pointer&gt; will cause callback be treated as a common functor object, vice versa. <br/>
</p>
<p>For any functions that expect <a class="el" href="classcpgf_1_1_g_callback.html">GCallback</a> as parameter, global function and functor object can be used directly because it will be converted implicitly. <br/>
</p>
<p>Note: <br/>
 1, When passing functor object (functor) to callback, if the object is volatile or const volatile, a volatile copy constructor must be specified as well as a const copy constructor. <br/>
 However, that will generator a "warning C4521:  multiple copy constructors specified" in VC. Seems it's a problem of VC (fine in GCC), so just use pragma warning (disable : 4521) to disable that warning. <br/>
 2, For the functor object passed to callback, it must either not define operator ==, or define operator == as public member. It mustn't declare the operator == in non-public section. <br/>
 3, For functor object, it must provide copy constructor. If it can't, use makeReference to get a reference. <br/>
 4, For functor object, the non-const operator function is always used if there is one. If there is no non-const version, the const version will be used.</p>
<p>How to compare two callbacks <br/>
 A callback is comparable only if the object or function is comparable. <br/>
 So, a callback with global function, or static memeber function, or normal member function, is always comparable. <br/>
 A callback with a functor object is only comparable when the functor is comparable (== operator is defined) <br/>
 For functor-only object which is only used to execute the () operator, an "always return true" == operator will be fine. <br/>
 </p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">bool</span> <a class="code" href="classcpgf_1_1_g_callback.html#a6a73bd959204ba89c1e7daee034d8215">operator == </a>(<span class="keyword">const</span> FunctorClass &amp;)<span class="keyword"> const </span>{
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
      }
</pre></div><p>How to change the max parameter count? <br/>
 The max parameter count is defined by CB_MAX_ARITY. <br/>
 So to change it, define CB_MAX_ARITY with a new value (1~30) before include <a class="el" href="gcallback_8h_source.html">gcallback.h</a> or <a class="el" href="gcallbacklist_8h_source.html">gcallbacklist.h</a>. <br/>
 If you need more than 30 parameters, you need to extend the macros in gpp.h which is quite tricky. <br/>
 <b> Note: usually you don't need to redefine CB_MAX_ARITY. It being 10 means you can use 0~10 parameters, not only 10 parameters. And 10 parameters are enough for most use.</b> </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a854d801eef209bf5172d1d0b1e61fda5"></a><!-- doxytag: member="cpgf::GCallback::GCallback" ref="a854d801eef209bf5172d1d0b1e61fda5" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpgf_1_1_g_callback.html">cpgf::GCallback</a>&lt; Signature &gt;::<a class="el" href="classcpgf_1_1_g_callback.html">GCallback</a> </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct an empty callback. Invoking an empty callback will cause nothing happen. </p>

</div>
</div>
<a class="anchor" id="aaf9d350059615fc81580a7db8ab4c951"></a><!-- doxytag: member="cpgf::GCallback::GCallback" ref="aaf9d350059615fc81580a7db8ab4c951" args="(OT *obj, const FT &amp;func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature&gt; </div>
<div class="memtemplate">
template&lt;typename OT , typename FT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpgf_1_1_g_callback.html">cpgf::GCallback</a>&lt; Signature &gt;::<a class="el" href="classcpgf_1_1_g_callback.html">GCallback</a> </td>
          <td>(</td>
          <td class="paramtype">OT *&#160;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FT &amp;&#160;</td>
          <td class="paramname"> <em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a callback from a member function. <br/>
 obj is the object, can be NULL and setObject later. <br/>
 func is the address of the function. <br/>
 Note: invoking a callback with NULL object will cause memory access violation. <br/>
 </p>

</div>
</div>
<a class="anchor" id="a0c13710db5e9189390f612d2ded90797"></a><!-- doxytag: member="cpgf::GCallback::GCallback" ref="a0c13710db5e9189390f612d2ded90797" args="(FT &amp;func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature&gt; </div>
<div class="memtemplate">
template&lt;typename FT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpgf_1_1_g_callback.html">cpgf::GCallback</a>&lt; Signature &gt;::<a class="el" href="classcpgf_1_1_g_callback.html">GCallback</a> </td>
          <td>(</td>
          <td class="paramtype">FT &amp;&#160;</td>
          <td class="paramname"> <em>func</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a callback from a global function or functor object. <br/>
 func is the address of the function, or a reference (not address) of the functor object. </p>

</div>
</div>
<a class="anchor" id="a16590124d158082c9a21061d578ee94e"></a><!-- doxytag: member="cpgf::GCallback::GCallback" ref="a16590124d158082c9a21061d578ee94e" args="(const FT &amp;func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature&gt; </div>
<div class="memtemplate">
template&lt;typename FT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpgf_1_1_g_callback.html">cpgf::GCallback</a>&lt; Signature &gt;::<a class="el" href="classcpgf_1_1_g_callback.html">GCallback</a> </td>
          <td>(</td>
          <td class="paramtype">const FT &amp;&#160;</td>
          <td class="paramname"> <em>func</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a callback from a global function or functor object. <br/>
 func is the address of the function, or a reference (not address) of the functor object. </p>

</div>
</div>
<a class="anchor" id="ae85101703c93a919986bbf4cc5ecac7c"></a><!-- doxytag: member="cpgf::GCallback::GCallback" ref="ae85101703c93a919986bbf4cc5ecac7c" args="(const volatile FT &amp;func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature&gt; </div>
<div class="memtemplate">
template&lt;typename FT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpgf_1_1_g_callback.html">cpgf::GCallback</a>&lt; Signature &gt;::<a class="el" href="classcpgf_1_1_g_callback.html">GCallback</a> </td>
          <td>(</td>
          <td class="paramtype">const volatile FT &amp;&#160;</td>
          <td class="paramname"> <em>func</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a callback from a global function or functor object. <br/>
 func is the address of the function, or a reference (not address) of the functor object. </p>

</div>
</div>
<a class="anchor" id="a42731a458a6ef642b2c9f7a0d57bef00"></a><!-- doxytag: member="cpgf::GCallback::GCallback" ref="a42731a458a6ef642b2c9f7a0d57bef00" args="(const ThisType &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpgf_1_1_g_callback.html">cpgf::GCallback</a>&lt; Signature &gt;::<a class="el" href="classcpgf_1_1_g_callback.html">GCallback</a> </td>
          <td>(</td>
          <td class="paramtype">const ThisType &amp;&#160;</td>
          <td class="paramname"> <em>other</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a callback from other callback. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="add48364194dc7d858c58d75b571d9c56"></a><!-- doxytag: member="cpgf::GCallback::operator=" ref="add48364194dc7d858c58d75b571d9c56" args="(const ThisType &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpgf_1_1_g_callback.html">GCallback</a>&amp; <a class="el" href="classcpgf_1_1_g_callback.html">cpgf::GCallback</a>&lt; Signature &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const ThisType &amp;&#160;</td>
          <td class="paramname"> <em>other</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign a callback from other callback. </p>

</div>
</div>
<a class="anchor" id="a6a73bd959204ba89c1e7daee034d8215"></a><!-- doxytag: member="cpgf::GCallback::operator==" ref="a6a73bd959204ba89c1e7daee034d8215" args="(const ThisType &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpgf_1_1_g_callback.html">cpgf::GCallback</a>&lt; Signature &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const ThisType &amp;&#160;</td>
          <td class="paramname"> <em>other</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Equal operator. </p>

</div>
</div>
<a class="anchor" id="a5f6e947139194c9442b3d11db6bde901"></a><!-- doxytag: member="cpgf::GCallback::operator!=" ref="a5f6e947139194c9442b3d11db6bde901" args="(const ThisType &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpgf_1_1_g_callback.html">cpgf::GCallback</a>&lt; Signature &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const ThisType &amp;&#160;</td>
          <td class="paramname"> <em>other</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Not-equal operator. </p>

</div>
</div>
<a class="anchor" id="a28bf091f14899532b86828a6eed25aad"></a><!-- doxytag: member="cpgf::GCallback::invoke" ref="a28bf091f14899532b86828a6eed25aad" args="(PT1 p1, PT2 p2...PTn pn) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RT <a class="el" href="classcpgf_1_1_g_callback.html">cpgf::GCallback</a>&lt; Signature &gt;::invoke </td>
          <td>(</td>
          <td class="paramtype">PT1&#160;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PT2 p2...PTn&#160;</td>
          <td class="paramname"> <em>pn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoke the callback. <br/>
 </p>
<div class="fragment"><pre class="fragment">            GCallback&lt;int, double&gt; cb = &amp;foo;
            <span class="keywordtype">int</span> a = cb.invoke(0.5); <span class="comment">// same as int a = foo(0.5);</span>
</pre></div> 
</div>
</div>
<a class="anchor" id="a26af038aa5e1d796e39547e73929fa1a"></a><!-- doxytag: member="cpgf::GCallback::operator()" ref="a26af038aa5e1d796e39547e73929fa1a" args="(PT1 p1, PT2 p2...PTn pn) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RT <a class="el" href="classcpgf_1_1_g_callback.html">cpgf::GCallback</a>&lt; Signature &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">PT1&#160;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PT2 p2...PTn&#160;</td>
          <td class="paramname"> <em>pn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoke the callback. <br/>
 </p>
<div class="fragment"><pre class="fragment">            GCallback&lt;int, double&gt; cb = &amp;foo;
            <span class="keywordtype">int</span> a = cb(0.5); <span class="comment">// same as int a = foo(0.5);</span>
</pre></div> 
</div>
</div>
<a class="anchor" id="abf7261ff1c6a5cc18cdae7bad96b769d"></a><!-- doxytag: member="cpgf::GCallback::getObject" ref="abf7261ff1c6a5cc18cdae7bad96b769d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const void* <a class="el" href="classcpgf_1_1_g_callback.html">cpgf::GCallback</a>&lt; Signature &gt;::getObject </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the object that bound to a member function. <br/>
 For non-member function, always return NULL. </p>

</div>
</div>
<a class="anchor" id="ab5e87163ad1fde5de29c4aa9ac48fca1"></a><!-- doxytag: member="cpgf::GCallback::setObject" ref="ab5e87163ad1fde5de29c4aa9ac48fca1" args="(void *obj)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcpgf_1_1_g_callback.html">cpgf::GCallback</a>&lt; Signature &gt;::setObject </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>obj</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the object to bind to a member function. <br/>
 No effect for non-member function. </p>

</div>
</div>
<a class="anchor" id="a63ba97a83eda4474bcfcf5ab7e31edfc"></a><!-- doxytag: member="cpgf::GCallback::empty" ref="a63ba97a83eda4474bcfcf5ab7e31edfc" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpgf_1_1_g_callback.html">cpgf::GCallback</a>&lt; Signature &gt;::empty </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if no function is set to the callback. <br/>
 Return false if there is function. </p>

</div>
</div>
</div>
<hr class="footer"/>
<br />
<div style="text-align:center">
Copyright &copy; 2011 by <a href="http://www.kbasm.com/">Wang Qi</a>
</div>
</body>
</html>
