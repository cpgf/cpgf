<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cppcallback: cpgf::GCallbackList&lt; Signature, ConnectionT, ListType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacecpgf.html">cpgf</a>      </li>
      <li><a class="el" href="classcpgf_1_1_g_callback_list.html">GCallbackList</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>cpgf::GCallbackList&lt; Signature, ConnectionT, ListType &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="cpgf::GCallbackList" -->
<p><code>#include &lt;<a class="el" href="gcallbacklist_8h_source.html">gcallbacklist.h</a>&gt;</code></p>

<p><a href="classcpgf_1_1_g_callback_list-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef super::GCallbackConnection&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback_list.html#a781d54c82d8f3e1a722b78bd54b5b69d">ConnectionType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcpgf_1_1_g_callback.html">GCallback</a>&lt; RT, PT1, <br class="typebreak"/>
PT2...PTn &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback_list.html#a220766499b2b8f27a164bd3f2f11b43c">CallbackType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef cpgf::GWiseList<br class="typebreak"/>
&lt; <a class="el" href="classcpgf_1_1_g_callback_connection.html">GCallbackConnection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback_list.html#aadec0b8abd37483954dcaf73feb030c2">DirectListType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef DirectListType::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback_list.html#a9f6e9f2c8b03773b08cc42a54dff3629">IteratorType</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback_list.html#ac3bb12e61ed55675a8781337f5332a7a">GCallbackList</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback_list.html#a8bc1673f7ba2c0bfe863824f6e92ac48">GCallbackList</a> (const <a class="el" href="classcpgf_1_1_g_callback_list.html">GCallbackList</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcpgf_1_1_g_callback_list.html">GCallbackList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback_list.html#a8b9944dc87aa5e999e762b2aff1d1a36">operator=</a> (const <a class="el" href="classcpgf_1_1_g_callback_list.html">GCallbackList</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback_list.html#af28dbe3ec7e79c1a50b225ca7f295852">dispatch</a> (PT1 p1, PT2 p2...PTn pn) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback_list.html#a9c214a5ef981eb8d91f438a6fe0c1812">operator()</a> (PT1 p1, PT2 p2...PTn pn) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename FT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpgf_1_1_g_callback_list.html#a781d54c82d8f3e1a722b78bd54b5b69d">ConnectionType</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback_list.html#a03282bd7be954c0c41d6c4662f5e55eb">add</a> (const FT &amp;func)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename FT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpgf_1_1_g_callback_list.html#a781d54c82d8f3e1a722b78bd54b5b69d">ConnectionType</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback_list.html#ab4664cfd03226915ac58a4da67207aeb">add</a> (const FT &amp;func, <a class="el" href="classcpgf_1_1_g_callback_trackable.html">GCallbackTrackable</a> *trackable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcpgf_1_1_g_callback_list.html#a781d54c82d8f3e1a722b78bd54b5b69d">ConnectionType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback_list.html#a1318078131980823cfab1c6d40a626ba">add</a> (const <a class="el" href="classcpgf_1_1_g_callback.html">CallbackType</a> &amp;cb)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcpgf_1_1_g_callback_list.html#a781d54c82d8f3e1a722b78bd54b5b69d">ConnectionType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback_list.html#a801edd49dc818569a4d36a36fde63f0d">add</a> (const <a class="el" href="classcpgf_1_1_g_callback.html">CallbackType</a> &amp;cb, <a class="el" href="classcpgf_1_1_g_callback_trackable.html">GCallbackTrackable</a> *trackable)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename OT , typename FT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpgf_1_1_g_callback_list.html#a781d54c82d8f3e1a722b78bd54b5b69d">ConnectionType</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback_list.html#a2c112fc1c6af9db0619528f44badb79d">add</a> (OT *obj, const FT &amp;func)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename OT , typename FT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpgf_1_1_g_callback_list.html#a781d54c82d8f3e1a722b78bd54b5b69d">ConnectionType</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback_list.html#a3462dbeacae9ba4586c9d09f753e4216">add</a> (OT *obj, const FT &amp;func, <a class="el" href="classcpgf_1_1_g_callback_trackable.html">GCallbackTrackable</a> *trackable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback_list.html#af28168a459dffa45460cc086fd8bd6bb">remove</a> (const <a class="el" href="classcpgf_1_1_g_callback.html">CallbackType</a> &amp;cb)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename OT , typename FT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback_list.html#a29da560701b7a7c499772e198863a3e1">remove</a> (OT *obj, const FT &amp;func)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback_list.html#acfeb725c7d8f8802e526e1686bb00209">remove</a> (<a class="el" href="classcpgf_1_1_g_callback_list.html#a781d54c82d8f3e1a722b78bd54b5b69d">ConnectionType</a> *connection)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback_list.html#aaeed0095ecbe63537c3858a35a20384a">remove</a> (int tag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcpgf_1_1_g_callback_list.html#a781d54c82d8f3e1a722b78bd54b5b69d">ConnectionType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback_list.html#a91f0dc1cd6d36f15c0441cadea1944e2">find</a> (const <a class="el" href="classcpgf_1_1_g_callback.html">CallbackType</a> &amp;cb) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename OT , typename FT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcpgf_1_1_g_callback_list.html#a781d54c82d8f3e1a722b78bd54b5b69d">ConnectionType</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback_list.html#aafdaad86b96f6c52353e268550fe7643">find</a> (OT *obj, const FT &amp;func) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcpgf_1_1_g_callback_list.html#a781d54c82d8f3e1a722b78bd54b5b69d">ConnectionType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback_list.html#ab326ea9b300948ce6444871627556c56">find</a> (int tag) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback_list.html#a455247bab89360a56b35e646bfcf158a">clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback_list.html#aa42a817060010b24b3c03a77684b8181">track</a> (<a class="el" href="classcpgf_1_1_g_callback_trackable.html">GCallbackTrackable</a> *trackable, void *connection)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback_list.html#a4920e0baaf26ae7c41061f0edc54e80d">cancel</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback_list.html#a30ba71dcb20ba87f4e7c7cbb59bdce1b">empty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcpgf_1_1_g_callback_list.html#aadec0b8abd37483954dcaf73feb030c2">DirectListType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback_list.html#af453bf0092339326d34fa92138b79ae3">getDirectList</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcpgf_1_1_g_callback_list.html#aadec0b8abd37483954dcaf73feb030c2">DirectListType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpgf_1_1_g_callback_list.html#aa44420c6df13476b8889a7350205e712">getDirectList</a> () const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename Signature, template&lt; typename &gt; class ConnectionT = GCallbackConnection, template&lt; typename T, typename=std::allocator&lt; T &gt; &gt; class ListType = cpgf::GWiseList&gt;<br/>
 class cpgf::GCallbackList&lt; Signature, ConnectionT, ListType &gt;</h3>

<p>The callback list is useful to hold multiple callbacks. <br/>
 The callback list is the same concept of signal in other implementation, such as Qt, boost::Signals, and libsigc++. <br/>
 The template parameter 'Signature' is the function type, or a pointer type that points to a function (aka, function pointer). <br/>
 The template parameter 'ConnectionT' is the connection type, see <a class="el" href="classcpgf_1_1_g_callback_connection.html">GCallbackConnection</a> and <a class="el" href="classcpgf_1_1_g_callback_extended_connection.html">GCallbackExtendedConnection</a>. The default value is <a class="el" href="classcpgf_1_1_g_callback_connection.html">GCallbackConnection</a>. <br/>
 The template parameter 'ListType' is the internal list type to manage the callbacks. It must be STL list compatible. The default value is cpgf::GWiseList. <br/>
</p>
<p>About the Signature, you can read document of <a class="el" href="classcpgf_1_1_g_callback.html">GCallback</a> for more information. <br/>
</p>
<p>Callback list is copyable. Copying a callback list will cause all callbacks duplicated to another list. <br/>
 But keep in mind that copying a callback list is quite expensive (iterate over the internal list, duplicate each callback, insert to new list). <br/>
 So it will be better to avoid copying a callback list. <br/>
 </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a781d54c82d8f3e1a722b78bd54b5b69d"></a><!-- doxytag: member="cpgf::GCallbackList::ConnectionType" ref="a781d54c82d8f3e1a722b78bd54b5b69d" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , template&lt; typename &gt; class ConnectionT = GCallbackConnection, template&lt; typename T, typename=std::allocator&lt; T &gt; &gt; class ListType = cpgf::GWiseList&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef super::GCallbackConnection <a class="el" href="classcpgf_1_1_g_callback_list.html">cpgf::GCallbackList</a>&lt; Signature, ConnectionT, ListType &gt;::<a class="el" href="classcpgf_1_1_g_callback_list.html#a781d54c82d8f3e1a722b78bd54b5b69d">ConnectionType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Connection class type. <br/>
 A connection object will be returned by "add" function. </p>

</div>
</div>
<a class="anchor" id="a220766499b2b8f27a164bd3f2f11b43c"></a><!-- doxytag: member="cpgf::GCallbackList::CallbackType" ref="a220766499b2b8f27a164bd3f2f11b43c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , template&lt; typename &gt; class ConnectionT = GCallbackConnection, template&lt; typename T, typename=std::allocator&lt; T &gt; &gt; class ListType = cpgf::GWiseList&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcpgf_1_1_g_callback.html">GCallback</a>&lt;RT, PT1, PT2 ... PTn &gt; <a class="el" href="classcpgf_1_1_g_callback_list.html">cpgf::GCallbackList</a>&lt; Signature, ConnectionT, ListType &gt;::<a class="el" href="classcpgf_1_1_g_callback.html">CallbackType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Callback type. <br/>
 Can be used to declare new callbacks. </p>

</div>
</div>
<a class="anchor" id="aadec0b8abd37483954dcaf73feb030c2"></a><!-- doxytag: member="cpgf::GCallbackList::DirectListType" ref="aadec0b8abd37483954dcaf73feb030c2" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , template&lt; typename &gt; class ConnectionT = GCallbackConnection, template&lt; typename T, typename=std::allocator&lt; T &gt; &gt; class ListType = cpgf::GWiseList&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef cpgf::GWiseList&lt;<a class="el" href="classcpgf_1_1_g_callback_connection.html">GCallbackConnection</a>&gt; <a class="el" href="classcpgf_1_1_g_callback_list.html">cpgf::GCallbackList</a>&lt; Signature, ConnectionT, ListType &gt;::<a class="el" href="classcpgf_1_1_g_callback_list.html#aadec0b8abd37483954dcaf73feb030c2">DirectListType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The internal list type. <br/>
 The list can be accessed by calling getDirectList. </p>

</div>
</div>
<a class="anchor" id="a9f6e9f2c8b03773b08cc42a54dff3629"></a><!-- doxytag: member="cpgf::GCallbackList::IteratorType" ref="a9f6e9f2c8b03773b08cc42a54dff3629" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , template&lt; typename &gt; class ConnectionT = GCallbackConnection, template&lt; typename T, typename=std::allocator&lt; T &gt; &gt; class ListType = cpgf::GWiseList&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef DirectListType::iterator <a class="el" href="classcpgf_1_1_g_callback_list.html">cpgf::GCallbackList</a>&lt; Signature, ConnectionT, ListType &gt;::<a class="el" href="classcpgf_1_1_g_callback_list.html#a9f6e9f2c8b03773b08cc42a54dff3629">IteratorType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The iterator type to go over DirectListType. </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac3bb12e61ed55675a8781337f5332a7a"></a><!-- doxytag: member="cpgf::GCallbackList::GCallbackList" ref="ac3bb12e61ed55675a8781337f5332a7a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , template&lt; typename &gt; class ConnectionT = GCallbackConnection, template&lt; typename T, typename=std::allocator&lt; T &gt; &gt; class ListType = cpgf::GWiseList&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpgf_1_1_g_callback_list.html">cpgf::GCallbackList</a>&lt; Signature, ConnectionT, ListType &gt;::<a class="el" href="classcpgf_1_1_g_callback_list.html">GCallbackList</a> </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a callback list. </p>

</div>
</div>
<a class="anchor" id="a8bc1673f7ba2c0bfe863824f6e92ac48"></a><!-- doxytag: member="cpgf::GCallbackList::GCallbackList" ref="a8bc1673f7ba2c0bfe863824f6e92ac48" args="(const GCallbackList &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , template&lt; typename &gt; class ConnectionT = GCallbackConnection, template&lt; typename T, typename=std::allocator&lt; T &gt; &gt; class ListType = cpgf::GWiseList&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpgf_1_1_g_callback_list.html">cpgf::GCallbackList</a>&lt; Signature, ConnectionT, ListType &gt;::<a class="el" href="classcpgf_1_1_g_callback_list.html">GCallbackList</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcpgf_1_1_g_callback_list.html">GCallbackList</a>&lt; Signature, ConnectionT, ListType &gt; &amp;&#160;</td>
          <td class="paramname"> <em>other</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a callback list from another list. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a8b9944dc87aa5e999e762b2aff1d1a36"></a><!-- doxytag: member="cpgf::GCallbackList::operator=" ref="a8b9944dc87aa5e999e762b2aff1d1a36" args="(const GCallbackList &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , template&lt; typename &gt; class ConnectionT = GCallbackConnection, template&lt; typename T, typename=std::allocator&lt; T &gt; &gt; class ListType = cpgf::GWiseList&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpgf_1_1_g_callback_list.html">GCallbackList</a>&amp; <a class="el" href="classcpgf_1_1_g_callback_list.html">cpgf::GCallbackList</a>&lt; Signature, ConnectionT, ListType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcpgf_1_1_g_callback_list.html">GCallbackList</a>&lt; Signature, ConnectionT, ListType &gt; &amp;&#160;</td>
          <td class="paramname"> <em>other</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign operator. </p>

</div>
</div>
<a class="anchor" id="af28dbe3ec7e79c1a50b225ca7f295852"></a><!-- doxytag: member="cpgf::GCallbackList::dispatch" ref="af28dbe3ec7e79c1a50b225ca7f295852" args="(PT1 p1, PT2 p2...PTn pn) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , template&lt; typename &gt; class ConnectionT = GCallbackConnection, template&lt; typename T, typename=std::allocator&lt; T &gt; &gt; class ListType = cpgf::GWiseList&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcpgf_1_1_g_callback_list.html">cpgf::GCallbackList</a>&lt; Signature, ConnectionT, ListType &gt;::dispatch </td>
          <td>(</td>
          <td class="paramtype">PT1&#160;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PT2 p2...PTn&#160;</td>
          <td class="paramname"> <em>pn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoke the callbacks. <br/>
 Doesn't support return value. <br/>
 If return value does matter, use getDirectList to access the internal list and call each callbacks manually. </p>

</div>
</div>
<a class="anchor" id="a9c214a5ef981eb8d91f438a6fe0c1812"></a><!-- doxytag: member="cpgf::GCallbackList::operator()" ref="a9c214a5ef981eb8d91f438a6fe0c1812" args="(PT1 p1, PT2 p2...PTn pn) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , template&lt; typename &gt; class ConnectionT = GCallbackConnection, template&lt; typename T, typename=std::allocator&lt; T &gt; &gt; class ListType = cpgf::GWiseList&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcpgf_1_1_g_callback_list.html">cpgf::GCallbackList</a>&lt; Signature, ConnectionT, ListType &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">PT1&#160;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PT2 p2...PTn&#160;</td>
          <td class="paramname"> <em>pn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoke the callbacks. Same as dispatch. </p>

</div>
</div>
<a class="anchor" id="a03282bd7be954c0c41d6c4662f5e55eb"></a><!-- doxytag: member="cpgf::GCallbackList::add" ref="a03282bd7be954c0c41d6c4662f5e55eb" args="(const FT &amp;func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , template&lt; typename &gt; class ConnectionT = GCallbackConnection, template&lt; typename T, typename=std::allocator&lt; T &gt; &gt; class ListType = cpgf::GWiseList&gt; </div>
<div class="memtemplate">
template&lt;typename FT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpgf_1_1_g_callback_list.html#a781d54c82d8f3e1a722b78bd54b5b69d">ConnectionType</a>* <a class="el" href="classcpgf_1_1_g_callback_list.html">cpgf::GCallbackList</a>&lt; Signature, ConnectionT, ListType &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const FT &amp;&#160;</td>
          <td class="paramname"> <em>func</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a global function or functor object to list. <br/>
 Return a connection which can be used to control the callback such as set tag. <br/>
 Usually you don't need to retain the connection. <br/>
 This function is introduced to optimize to avoid unnecessary object copy. </p>

</div>
</div>
<a class="anchor" id="ab4664cfd03226915ac58a4da67207aeb"></a><!-- doxytag: member="cpgf::GCallbackList::add" ref="ab4664cfd03226915ac58a4da67207aeb" args="(const FT &amp;func, GCallbackTrackable *trackable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , template&lt; typename &gt; class ConnectionT = GCallbackConnection, template&lt; typename T, typename=std::allocator&lt; T &gt; &gt; class ListType = cpgf::GWiseList&gt; </div>
<div class="memtemplate">
template&lt;typename FT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpgf_1_1_g_callback_list.html#a781d54c82d8f3e1a722b78bd54b5b69d">ConnectionType</a>* <a class="el" href="classcpgf_1_1_g_callback_list.html">cpgf::GCallbackList</a>&lt; Signature, ConnectionT, ListType &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const FT &amp;&#160;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpgf_1_1_g_callback_trackable.html">GCallbackTrackable</a> *&#160;</td>
          <td class="paramname"> <em>trackable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a global function or functor object to list. <br/>
 Return a connection which can be used to control the callback such as set tag. <br/>
 Usually you don't need to retain the connection. <br/>
 This function is introduced to optimize to avoid unnecessary object copy. </p>

</div>
</div>
<a class="anchor" id="a1318078131980823cfab1c6d40a626ba"></a><!-- doxytag: member="cpgf::GCallbackList::add" ref="a1318078131980823cfab1c6d40a626ba" args="(const CallbackType &amp;cb)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , template&lt; typename &gt; class ConnectionT = GCallbackConnection, template&lt; typename T, typename=std::allocator&lt; T &gt; &gt; class ListType = cpgf::GWiseList&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpgf_1_1_g_callback_list.html#a781d54c82d8f3e1a722b78bd54b5b69d">ConnectionType</a>* <a class="el" href="classcpgf_1_1_g_callback_list.html">cpgf::GCallbackList</a>&lt; Signature, ConnectionT, ListType &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcpgf_1_1_g_callback.html">CallbackType</a> &amp;&#160;</td>
          <td class="paramname"> <em>cb</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a callback to list. <br/>
 Return a connection which can be used to control the callback such as set tag. <br/>
 Usually you don't need to retain the connection. <br/>
 Note: global function or functor object can be added directly using this function without converting to callback because it will be converted implicitly. </p>

</div>
</div>
<a class="anchor" id="a801edd49dc818569a4d36a36fde63f0d"></a><!-- doxytag: member="cpgf::GCallbackList::add" ref="a801edd49dc818569a4d36a36fde63f0d" args="(const CallbackType &amp;cb, GCallbackTrackable *trackable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , template&lt; typename &gt; class ConnectionT = GCallbackConnection, template&lt; typename T, typename=std::allocator&lt; T &gt; &gt; class ListType = cpgf::GWiseList&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpgf_1_1_g_callback_list.html#a781d54c82d8f3e1a722b78bd54b5b69d">ConnectionType</a>* <a class="el" href="classcpgf_1_1_g_callback_list.html">cpgf::GCallbackList</a>&lt; Signature, ConnectionT, ListType &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcpgf_1_1_g_callback.html">CallbackType</a> &amp;&#160;</td>
          <td class="paramname"> <em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpgf_1_1_g_callback_trackable.html">GCallbackTrackable</a> *&#160;</td>
          <td class="paramname"> <em>trackable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a callback to list and track the connection. <br/>
 Return a connection which can be used to control the callback such as set tag. <br/>
 Usually you don't need to retain the connection. <br/>
 Note: global function or functor object can be added directly using this function without converting to callback because it will be converted implicitly. </p>

</div>
</div>
<a class="anchor" id="a2c112fc1c6af9db0619528f44badb79d"></a><!-- doxytag: member="cpgf::GCallbackList::add" ref="a2c112fc1c6af9db0619528f44badb79d" args="(OT *obj, const FT &amp;func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , template&lt; typename &gt; class ConnectionT = GCallbackConnection, template&lt; typename T, typename=std::allocator&lt; T &gt; &gt; class ListType = cpgf::GWiseList&gt; </div>
<div class="memtemplate">
template&lt;typename OT , typename FT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpgf_1_1_g_callback_list.html#a781d54c82d8f3e1a722b78bd54b5b69d">ConnectionType</a>* <a class="el" href="classcpgf_1_1_g_callback_list.html">cpgf::GCallbackList</a>&lt; Signature, ConnectionT, ListType &gt;::add </td>
          <td>(</td>
          <td class="paramtype">OT *&#160;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FT &amp;&#160;</td>
          <td class="paramname"> <em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a member function to list. <br/>
 Return a connection which can be used to control the callback such as set tag. <br/>
 Usually you don't need to retain the connection. </p>

</div>
</div>
<a class="anchor" id="a3462dbeacae9ba4586c9d09f753e4216"></a><!-- doxytag: member="cpgf::GCallbackList::add" ref="a3462dbeacae9ba4586c9d09f753e4216" args="(OT *obj, const FT &amp;func, GCallbackTrackable *trackable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , template&lt; typename &gt; class ConnectionT = GCallbackConnection, template&lt; typename T, typename=std::allocator&lt; T &gt; &gt; class ListType = cpgf::GWiseList&gt; </div>
<div class="memtemplate">
template&lt;typename OT , typename FT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpgf_1_1_g_callback_list.html#a781d54c82d8f3e1a722b78bd54b5b69d">ConnectionType</a>* <a class="el" href="classcpgf_1_1_g_callback_list.html">cpgf::GCallbackList</a>&lt; Signature, ConnectionT, ListType &gt;::add </td>
          <td>(</td>
          <td class="paramtype">OT *&#160;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FT &amp;&#160;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcpgf_1_1_g_callback_trackable.html">GCallbackTrackable</a> *&#160;</td>
          <td class="paramname"> <em>trackable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a member function to list and track the connection. <br/>
 Return a connection which can be used to control the callback such as set tag. <br/>
 Usually you don't need to retain the connection. </p>

</div>
</div>
<a class="anchor" id="af28168a459dffa45460cc086fd8bd6bb"></a><!-- doxytag: member="cpgf::GCallbackList::remove" ref="af28168a459dffa45460cc086fd8bd6bb" args="(const CallbackType &amp;cb)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , template&lt; typename &gt; class ConnectionT = GCallbackConnection, template&lt; typename T, typename=std::allocator&lt; T &gt; &gt; class ListType = cpgf::GWiseList&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpgf_1_1_g_callback_list.html">cpgf::GCallbackList</a>&lt; Signature, ConnectionT, ListType &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcpgf_1_1_g_callback.html">CallbackType</a> &amp;&#160;</td>
          <td class="paramname"> <em>cb</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove first found callback from the list. <br/>
 Return true if success. <br/>
 Return false if not found. </p>

</div>
</div>
<a class="anchor" id="a29da560701b7a7c499772e198863a3e1"></a><!-- doxytag: member="cpgf::GCallbackList::remove" ref="a29da560701b7a7c499772e198863a3e1" args="(OT *obj, const FT &amp;func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , template&lt; typename &gt; class ConnectionT = GCallbackConnection, template&lt; typename T, typename=std::allocator&lt; T &gt; &gt; class ListType = cpgf::GWiseList&gt; </div>
<div class="memtemplate">
template&lt;typename OT , typename FT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpgf_1_1_g_callback_list.html">cpgf::GCallbackList</a>&lt; Signature, ConnectionT, ListType &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">OT *&#160;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FT &amp;&#160;</td>
          <td class="paramname"> <em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove first found callback which match the member function from the list. <br/>
 Return true if success. <br/>
 Return false if not found. </p>

</div>
</div>
<a class="anchor" id="acfeb725c7d8f8802e526e1686bb00209"></a><!-- doxytag: member="cpgf::GCallbackList::remove" ref="acfeb725c7d8f8802e526e1686bb00209" args="(ConnectionType *connection)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , template&lt; typename &gt; class ConnectionT = GCallbackConnection, template&lt; typename T, typename=std::allocator&lt; T &gt; &gt; class ListType = cpgf::GWiseList&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpgf_1_1_g_callback_list.html">cpgf::GCallbackList</a>&lt; Signature, ConnectionT, ListType &gt;::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcpgf_1_1_g_callback_list.html#a781d54c82d8f3e1a722b78bd54b5b69d">ConnectionType</a> *&#160;</td>
          <td class="paramname"> <em>connection</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove first found callback that owned by the connection from the list. <br/>
 Return true if success. <br/>
 Return false if not found. </p>

</div>
</div>
<a class="anchor" id="aaeed0095ecbe63537c3858a35a20384a"></a><!-- doxytag: member="cpgf::GCallbackList::remove" ref="aaeed0095ecbe63537c3858a35a20384a" args="(int tag)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , template&lt; typename &gt; class ConnectionT = GCallbackConnection, template&lt; typename T, typename=std::allocator&lt; T &gt; &gt; class ListType = cpgf::GWiseList&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpgf_1_1_g_callback_list.html">cpgf::GCallbackList</a>&lt; Signature, ConnectionT, ListType &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>tag</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove first found callback that has the same tag from the list. <br/>
 Return true if success. <br/>
 Return false if not found. </p>

</div>
</div>
<a class="anchor" id="a91f0dc1cd6d36f15c0441cadea1944e2"></a><!-- doxytag: member="cpgf::GCallbackList::find" ref="a91f0dc1cd6d36f15c0441cadea1944e2" args="(const CallbackType &amp;cb) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , template&lt; typename &gt; class ConnectionT = GCallbackConnection, template&lt; typename T, typename=std::allocator&lt; T &gt; &gt; class ListType = cpgf::GWiseList&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpgf_1_1_g_callback_list.html#a781d54c82d8f3e1a722b78bd54b5b69d">ConnectionType</a>* <a class="el" href="classcpgf_1_1_g_callback_list.html">cpgf::GCallbackList</a>&lt; Signature, ConnectionT, ListType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcpgf_1_1_g_callback.html">CallbackType</a> &amp;&#160;</td>
          <td class="paramname"> <em>cb</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find a connection from a callback. <br/>
 Return NULL if not found. </p>

</div>
</div>
<a class="anchor" id="aafdaad86b96f6c52353e268550fe7643"></a><!-- doxytag: member="cpgf::GCallbackList::find" ref="aafdaad86b96f6c52353e268550fe7643" args="(OT *obj, const FT &amp;func) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , template&lt; typename &gt; class ConnectionT = GCallbackConnection, template&lt; typename T, typename=std::allocator&lt; T &gt; &gt; class ListType = cpgf::GWiseList&gt; </div>
<div class="memtemplate">
template&lt;typename OT , typename FT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpgf_1_1_g_callback_list.html#a781d54c82d8f3e1a722b78bd54b5b69d">ConnectionType</a>* <a class="el" href="classcpgf_1_1_g_callback_list.html">cpgf::GCallbackList</a>&lt; Signature, ConnectionT, ListType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">OT *&#160;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FT &amp;&#160;</td>
          <td class="paramname"> <em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find a connection from a member function. <br/>
 Return NULL if not found. </p>

</div>
</div>
<a class="anchor" id="ab326ea9b300948ce6444871627556c56"></a><!-- doxytag: member="cpgf::GCallbackList::find" ref="ab326ea9b300948ce6444871627556c56" args="(int tag) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , template&lt; typename &gt; class ConnectionT = GCallbackConnection, template&lt; typename T, typename=std::allocator&lt; T &gt; &gt; class ListType = cpgf::GWiseList&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpgf_1_1_g_callback_list.html#a781d54c82d8f3e1a722b78bd54b5b69d">ConnectionType</a>* <a class="el" href="classcpgf_1_1_g_callback_list.html">cpgf::GCallbackList</a>&lt; Signature, ConnectionT, ListType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>tag</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find a connection from a tag. <br/>
 Return NULL if not found. </p>

</div>
</div>
<a class="anchor" id="a455247bab89360a56b35e646bfcf158a"></a><!-- doxytag: member="cpgf::GCallbackList::clear" ref="a455247bab89360a56b35e646bfcf158a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , template&lt; typename &gt; class ConnectionT = GCallbackConnection, template&lt; typename T, typename=std::allocator&lt; T &gt; &gt; class ListType = cpgf::GWiseList&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcpgf_1_1_g_callback_list.html">cpgf::GCallbackList</a>&lt; Signature, ConnectionT, ListType &gt;::clear </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all callbacks. </p>

</div>
</div>
<a class="anchor" id="aa42a817060010b24b3c03a77684b8181"></a><!-- doxytag: member="cpgf::GCallbackList::track" ref="aa42a817060010b24b3c03a77684b8181" args="(GCallbackTrackable *trackable, void *connection)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , template&lt; typename &gt; class ConnectionT = GCallbackConnection, template&lt; typename T, typename=std::allocator&lt; T &gt; &gt; class ListType = cpgf::GWiseList&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcpgf_1_1_g_callback_list.html">cpgf::GCallbackList</a>&lt; Signature, ConnectionT, ListType &gt;::track </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcpgf_1_1_g_callback_trackable.html">GCallbackTrackable</a> *&#160;</td>
          <td class="paramname"> <em>trackable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Track a connection with a trackable object. </p>

</div>
</div>
<a class="anchor" id="a4920e0baaf26ae7c41061f0edc54e80d"></a><!-- doxytag: member="cpgf::GCallbackList::cancel" ref="a4920e0baaf26ae7c41061f0edc54e80d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , template&lt; typename &gt; class ConnectionT = GCallbackConnection, template&lt; typename T, typename=std::allocator&lt; T &gt; &gt; class ListType = cpgf::GWiseList&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcpgf_1_1_g_callback_list.html">cpgf::GCallbackList</a>&lt; Signature, ConnectionT, ListType &gt;::cancel </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel current dispatch. <br/>
 If this function is called during dispatch, all later callbacks will not be executed. </p>

</div>
</div>
<a class="anchor" id="a30ba71dcb20ba87f4e7c7cbb59bdce1b"></a><!-- doxytag: member="cpgf::GCallbackList::empty" ref="a30ba71dcb20ba87f4e7c7cbb59bdce1b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , template&lt; typename &gt; class ConnectionT = GCallbackConnection, template&lt; typename T, typename=std::allocator&lt; T &gt; &gt; class ListType = cpgf::GWiseList&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcpgf_1_1_g_callback_list.html">cpgf::GCallbackList</a>&lt; Signature, ConnectionT, ListType &gt;::empty </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if there is no callbacks in the list. </p>

</div>
</div>
<a class="anchor" id="af453bf0092339326d34fa92138b79ae3"></a><!-- doxytag: member="cpgf::GCallbackList::getDirectList" ref="af453bf0092339326d34fa92138b79ae3" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , template&lt; typename &gt; class ConnectionT = GCallbackConnection, template&lt; typename T, typename=std::allocator&lt; T &gt; &gt; class ListType = cpgf::GWiseList&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcpgf_1_1_g_callback_list.html#aadec0b8abd37483954dcaf73feb030c2">DirectListType</a>&amp; <a class="el" href="classcpgf_1_1_g_callback_list.html">cpgf::GCallbackList</a>&lt; Signature, ConnectionT, ListType &gt;::getDirectList </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the internal list. </p>

</div>
</div>
<a class="anchor" id="aa44420c6df13476b8889a7350205e712"></a><!-- doxytag: member="cpgf::GCallbackList::getDirectList" ref="aa44420c6df13476b8889a7350205e712" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , template&lt; typename &gt; class ConnectionT = GCallbackConnection, template&lt; typename T, typename=std::allocator&lt; T &gt; &gt; class ListType = cpgf::GWiseList&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcpgf_1_1_g_callback_list.html#aadec0b8abd37483954dcaf73feb030c2">DirectListType</a>&amp; <a class="el" href="classcpgf_1_1_g_callback_list.html">cpgf::GCallbackList</a>&lt; Signature, ConnectionT, ListType &gt;::getDirectList </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the internal list, const version. </p>

</div>
</div>
</div>
<hr class="footer"/>
<br />
<div style="text-align:center">
Copyright &copy; 2011 by <a href="http://www.kbasm.com/">Wang Qi</a>
</div>
</body>
</html>
