<html>
<head>
<title>
A benchmark of three C++ open source callback/signal/slot libraries -- CppCallback, libsigc++, and boost signal
</title>
</head>
<body><div style="width:1200px">


<p>
This is a benchmark comparison of the speed performance of three C++ signal/slot/callback libraries,
<a href="/cpp-callback-library.html">CppCallback</a>, libsigc++, and boost::signal2. <br />
The source code of the benchmark is included in the CppCallback package.
</p>

<table cols="6" align="center" border="1" style="width:100%;text-align:center;border-width:1px;border-spacing:0px;border-style:solid;border-color:gray;border-collapse:separate;background-color:#f6f6f6;">

<tr>
<td colspan="6">
Test environment
</td>
</tr>

<tr>
<td>
Hardware
</td>
<td colspan="5" style="text-align:left">
<ul>
<li>Intel(R) Pentium(R) Dual CPU E2180 2GHz<sup>(A)</sup>, 4G RAM. </li>
</ul>
</td>
</tr>

<tr>
<td>
Software
</td>
<td colspan="5" style="text-align:left">
<ul>
<li>Windows XP SP2. </li>
<li>VC 9 (Microsoft Visual Studio 2008 Express), with _SECURE_SCL<sup>(B)</sup> = 0 and _HAS_ITERATOR_DEBUGGING = 0. <br/> Optimization -O2. </li>
<li>MingW GCC 4.5.2. Optimization -O3. </li>
</ul>
</td>
</tr>

<tr style="background-color:#ffff99;font-weight:bold">
<td style="width:22%">Functions</td>

<td style="width:13%">Compiler</td>
<td style="width:13%">Native call<sup>(C)</sup></td>
<td style="width:13%"><a href="/cpp-callback-library.html">CppCallback</a> <br /> (gcallback)</td>
<td style="width:13%">LibSigC++ <br /> 2.2.8</td>
<td style="width:13%">Boost<sup>(D)</sup> Signal2 <br /> 1.46.0</td>
</tr>

<tr>
<td colspan="6" style="background-color:#ddddff">Single slot (callback) benchmark, <b>100M (100,000,000)</b> iterations. Time unit: milliseconds.</td>
</tr>

<tr style="background-color:#99ffff">
<td rowspan="2">Inline member function<sup>(E)</sup></td>
<td>VC 9</td>
<td>46</td>
<td>781</td>
<td>766</td>
<td>3547</td>
</tr>

<tr style="background-color:#99ffff">
<td>GCC 4.5.2</td>
<td>47</td>
<td>1047</td>
<td>1000</td>
<td>1875</td>
</tr>

<tr>
<td rowspan="2">Non-inline member function</td>
<td>VC 9</td>
<td>391</td>
<td>766</td>
<td>781</td>
<td>3515</td>
</tr>

<tr>
<td>GCC 4.5.2</td>
<td>453</td>
<td>1047</td>
<td>1000</td>
<td>1813</td>
</tr>

<tr style="background-color:#99ffff">
<td rowspan="2">Virtual member function</td>
<td>VC 9</td>
<td>359</td>
<td>719</td>
<td>672</td>
<td>3579</td>
</tr>

<tr style="background-color:#99ffff">
<td>GCC 4.5.2</td>
<td>406</td>
<td>1031</td>
<td>969</td>
<td>1750</td>
</tr>

<tr>
<td rowspan="2">global function</td>
<td>VC 9</td>
<td>47</td>
<td>719</td>
<td>734</td>
<td>3578</td>
</tr>

<tr>
<td>GCC 4.5.2</td>
<td>47</td>
<td>766</td>
<td>781</td>
<td>1562</td>
</tr>

<tr style="background-color:#99ffff">
<td rowspan="2">functor object</td>
<td>VC 9</td>
<td>47</td>
<td>468</td>
<td>438</td>
<td>3156</td>
</tr>

<tr style="background-color:#99ffff">
<td>GCC 4.5.2</td>
<td>47</td>
<td>515</td>
<td>516</td>
<td>1547</td>
</tr>

<tr>
<td colspan="6" style="background-color:#ddddff">Signal<sup>(F)</sup> (callback list) benchmark, <b>10M (10,000,000)</b> iterations. Time unit: milliseconds.</td>
</tr>

<tr>
<td rowspan="2">Invoke empty signal</td>
<td>VC 9</td>
<td>N/A</td>
<td>63</td>
<td>93</td>
<td>2000</td>
</tr>

<tr>
<td>GCC 4.5.2</td>
<td>N/A</td>
<td>31</td>
<td>31</td>
<td>1703</td>
</tr>

<tr style="background-color:#99ffff">
<td rowspan="2">Invoke signal with 5 slots</td>
<td>VC 9</td>
<td>N/A</td>
<td>641</td>
<td>2734</td>
<td>8797</td>
</tr>

<tr style="background-color:#99ffff">
<td>GCC 4.5.2</td>
<td>N/A</td>
<td>578</td>
<td>2547</td>
<td>7515</td>
</tr>

<tr>
<td rowspan="2">Invoke signal with 10 slots</td>
<td>VC 9</td>
<td>N/A</td>
<td>1109</td>
<td>3328</td>
<td>15203</td>
</tr>

<tr>
<td>GCC 4.5.2</td>
<td>N/A</td>
<td>1094</td>
<td>3032</td>
<td>13063</td>
</tr>

<tr style="background-color:#99ffff">
<td rowspan="2">Invoke signal with 50 slots</td>
<td>VC 9</td>
<td>N/A</td>
<td>6735</td>
<td>7875</td>
<td>64813</td>
</tr>

<tr style="background-color:#99ffff">
<td>GCC 4.5.2</td>
<td>N/A</td>
<td>5109</td>
<td>6703</td>
<td>54969</td>
</tr>

<tr>
<td colspan="6" align="left">

Notes:
<ol style="list-style-type:upper-alpha">
	<li>The hardware used to test on is quite out of date. Any latest hardware will produce quite better performance. </li>
	<li>If you don't know why _SECURE_SCL should be 0, read my blog <a href="http://www.kbasm.com/cpp-vc-disable-checked-iterators-release-mode.html">here</a>.</li>
	<li>Native call is just invoking the functions directly. </li>
	<li>boost::signal2 is used in the benchmark instead of signal. Because signal2 is easy to use without linking to library, and boost::signal can't call slot directly. Also boost::signal2 is 50% faster than boost:signal. </li>
	<li>All callee functions, except the virtual functions, are not empty. They receive one int parameter and add it to a global variable. This is intended so the compilers won't eliminate the functions away. Function prototype: void (int). </li>
	<li>The slots that connected to the signal are various functions, include all inline, noninline, virtual, global, and functors. </li>
	<li>Some fast delegate code from codeproject was also tested, and they are one time faster than invoking slot of CppCallback and libsigc++. However, they are not counted in the table because they can't be used to implement signal/slot mechanism and they can't handle functor object. </li>
</ol>

</td>
</tr>

</table>

<br />

Some conclusions based on the data of CppCallback and libsigc++ that compiled with VC:
<ul>
	<li>For non-inline function, a slot, or a callback, has the same performance level as the native function call. Indeed a slot is only only 50% slower than a native call.</li>
	<li>The slot invoking performance is almost the same between CppCallback and libsigc++. </li>
	<li>A signle slot invoking is about equivalent to invoking a normal function via two function pointers, or call a virtual function two times. </li>
	<li>Functor object has the best performance. So always prefer it when possible. </li>
	<li>The slot invoking performance is enough for most purpose usage. 100M iterations only need up to 1000ms, which is average 10ns for a single call. That means if there are 10K slot invoking, only 0.1ms is spent on the invoking itself. 0.1ms is nothing for most high performance games. And don't forget this is the performance on quite old hardware. </li>
	<li>The callback list (signal) performance of CppCallback, for a single slot (note it's 5 slots in a signal in the benchmark) is 50% slower than one single slot call without callback list. That means if there are 10K slot invoking, only 0.2ms is spent on the invoking itself. That also means we can heavily use callbacks (signals) in a 60 FPS game without worrying the impact of the callbacks. </li>
	<li>When there are few slots (callbacks) in a signal (callback list), CppCallback has better performance than libsigc++ because CppCallback has less setup overhead before dispatching. When there are a lot of slots, the performance difference between CppCallback and libsigc++ is trivial. </li>
</ul>


</div></body>
</html>
